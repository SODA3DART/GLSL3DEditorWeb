<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GLSL Shader Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-glsl.min.js"></script>
  <style>
    /* Minimal PrismJS theme using Tailwind-like colors for GLSL */
    code[class*="language-"],
    pre[class*="language-"] {
      color: #d1d5db; /* gray-300 */
      background: none;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 1em;
      text-align: left;
      white-space: pre;
      word-spacing: normal;
      word-break: normal;
      word-wrap: normal;
      line-height: 1.5;
      -moz-tab-size: 4;
      -o-tab-size: 4;
      tab-size: 4;
      -webkit-hyphens: none;
      -moz-hyphens: none;
      -ms-hyphens: none;
      hyphens: none;
    }

    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
      color: #6b7280; /* gray-500 */
    }

    .token.punctuation {
      color: #9ca3af; /* gray-400 */
    }

    .token.property,
    .token.tag,
    .token.constant,
    .token.symbol,
    .token.deleted {
      color: #f87171; /* red-400 */
    }

    .token.boolean,
    .token.number {
      color: #facc15; /* yellow-400 */
    }

    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
      color: #a3e635; /* lime-400 */
    }

    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string,
    .token.variable {
      color: #60a5fa; /* blue-400 */
    }

    .token.atrule,
    .token.attr-value,
    .token.function,
    .token.class-name {
      color: #c084fc; /* purple-400 */
    }

    .token.keyword {
      color: #fb923c; /* orange-400 */
    }

    .token.regex,
    .token.important {
      color: #f472b6; /* pink-400 */
    }

    .token.important,
    .token.bold {
      font-weight: bold;
    }
    .token.italic {
      font-style: italic;
    }

    .token.entity {
      cursor: help;
    }

    #editor {
      position: relative;
      height: 400px;
      width: 100%;
      overflow: hidden;
    }

    #editor-textarea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 10px;
      color: transparent;
      background: transparent;
      caret-color: white;
      resize: none;
      border: none;
      outline: none;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 14px;
      line-height: 1.5;
      tab-size: 2;
      white-space: pre;
      overflow: auto;
      z-index: 2;
      letter-spacing: normal;
      word-spacing: normal;
      text-indent: 0;
      margin: 0;
      box-sizing: border-box;
    }

    #editor-highlight {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 10px;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      font-size: 14px;
      line-height: 1.5;
      tab-size: 2;
      white-space: pre;
      overflow: auto;
      pointer-events: none;
      z-index: 1;
      letter-spacing: normal;
      word-spacing: normal;
      text-indent: 0;
      margin: 0;
      box-sizing: border-box;
    }

    .editor-panel {
      background-color: rgba(31, 41, 55, 0.8);
      backdrop-filter: blur(8px);
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .drag-handle {
      cursor: move;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #shader-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 overflow-hidden">
  <div class="relative h-screen w-screen flex flex-col">
    <!-- Toggle Control Panel Button -->
    <button
      id="toggle-control-panel"
      class="fixed top-2 right-2 bg-gray-700 hover:bg-gray-600 text-white text-sm px-2 py-1 rounded z-40"
      aria-label="Toggle Control Panel"
    >
      Hide Controls
    </button>

    <!-- Controls Bar -->
    <div id="controls-bar" class="bg-gray-800 p-2 shadow-md z-30 flex items-center space-x-4">
      <span class="text-sm font-semibold">Mode:</span>
      <button 
        id="mode-2d"
        class="px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500"
      >
        2D
      </button>
      <button 
        id="mode-3d"
        class="px-3 py-1 rounded text-sm bg-indigo-500 text-white"
      >
        3D
      </button>
      <button 
        id="mode-ar"
        class="px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500"
      >
        AR
      </button>

      <div id="primitive-controls" class="ml-4 flex items-center space-x-2">
        <span class="text-sm font-semibold">Primitive:</span>
        <select 
          id="primitive-select"
          class="bg-gray-700 text-white p-1 rounded text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
        >
          <option value="Cube">Cube</option>
          <option value="Sphere">Sphere</option>
          <option value="UploadedOBJ">Upload Your OBJ Model</option>
        </select>
        <button 
          id="upload-obj"
          class="bg-teal-500 hover:bg-teal-600 text-white text-sm px-3 py-1 rounded"
        >
          Upload OBJ
        </button>
        <input 
          type="file" 
          id="obj-file-input" 
          accept=".obj" 
          class="hidden" 
        />
      </div>

      <div id="texture-controls" class="ml-4 flex items-center space-x-2">
        <span class="text-sm font-semibold">Textures:</span>
        <button 
          id="toggle-texture"
          class="bg-teal-500 hover:bg-teal-600 text-white text-sm px-3 py-1 rounded"
        >
          Show Textures
        </button>
        <input 
          type="file" 
          id="texture-file-input" 
          accept="image/*" 
          class="hidden" 
        />
      </div>
    </div>

    <!-- Texture Panel -->
    <div id="texture-panel" class="bg-gray-800 p-2 shadow-md z-30 flex items-center space-x-4 overflow-x-auto">
      <button 
        id="add-texture"
        class="bg-green-500 hover:bg-green-600 text-white text-sm px-3 py-1 rounded flex-shrink-0"
      >
        Add Texture
      </button>
      <div id="texture-list" class="flex items-center space-x-4 overflow-x-auto">
        <span class="text-gray-400 text-sm">No textures added yet. Click "Add Texture" to upload.</span>
      </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
      <canvas id="shader-canvas"></canvas>
    </div>

    <!-- Editor Panel -->
    <div id="editor-container" class="absolute top-24 left-4 w-full max-w-lg lg:max-w-xl editor-panel z-20 flex flex-col" style="min-height: 300px; max-height: 80vh;">
      <div class="drag-handle bg-gray-900 bg-opacity-70 p-2 flex justify-between items-center">
        <h2 class="text-sm font-semibold text-gray-200">GLSL Editor</h2>
        <button id="close-editor" class="text-gray-400 hover:text-white transition-colors" aria-label="Close Editor">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
          </svg>
        </button>
      </div>

      <div class="flex-grow p-1 overflow-y-auto bg-transparent" style="min-height: 200px;">
        <div id="editor">
          <textarea id="editor-textarea" spellcheck="false" aria-label="GLSL Code Editor"></textarea>
          <pre id="editor-highlight"><code class="language-glsl"></code></pre>
        </div>
      </div>

      <div id="error-container" class="p-3 bg-red-700 bg-opacity-70 text-red-100 text-xs font-mono flex items-start max-h-32 overflow-y-auto hidden">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
        </svg>
        <pre id="error-text" class="whitespace-pre-wrap flex-grow"></pre>
      </div>

      <div class="p-3 bg-gray-900 bg-opacity-70 flex justify-between items-center">
        <div class="flex items-center">
          <input 
            type="checkbox" 
            id="auto-compile-checkbox" 
            class="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500"
          />
          <label for="auto-compile-checkbox" class="ml-2 text-sm font-medium text-gray-300">
            Auto-compile (1s)
          </label>
        </div>
        <button
          id="compile-button"
          class="flex items-center bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition-all duration-150 ease-in-out"
          aria-label="Compile and Run Shader"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
          </svg>
          Compile & Run
        </button>
      </div>
    </div>

  </div>

  <script>
    // Constants
    const DEFAULT_VERTEX_SHADER_2D = `
attribute vec2 a_position;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

    const DEFAULT_FRAGMENT_SHADER_2D = `
precision mediump float;

uniform vec2 u_resolution;
uniform float u_time;

void main() {
  vec2 st = gl_FragCoord.xy / u_resolution.xy;
  // Simple time-varying color pattern
  float r = 0.5 + 0.5 * cos(u_time + st.x * 3.14159);
  float g = 0.5 + 0.5 * sin(u_time * 0.8 + st.y * 2.71828);
  float b = 0.5 + 0.5 * cos(u_time * 1.2 + (st.x + st.y) * 1.61803);
  gl_FragColor = vec4(r, g, b, 1.0);
}`;

    const DEFAULT_VERTEX_SHADER_3D = `
attribute vec3 a_position;
attribute vec3 a_normal;
attribute vec2 a_texcoord; // Texture coordinates (UV) - may be available if model has UVs

uniform mat4 u_modelMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_projectionMatrix;
uniform mat4 u_normalMatrix;

varying vec3 v_normal;
varying vec3 v_worldPosition;
varying vec2 v_texcoord; // Pass texture coordinates to fragment shader

void main() {
  vec4 worldPos = u_modelMatrix * vec4(a_position, 1.0);
  gl_Position = u_projectionMatrix * u_viewMatrix * worldPos;
  v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);
  v_worldPosition = worldPos.xyz;

  // Pass texture coordinates to fragment shader
  // If model doesn't have UVs, we'll generate them from position
  v_texcoord = a_texcoord;
}`;

    const DEFAULT_FRAGMENT_SHADER_3D = `
precision mediump float;

uniform vec2 u_resolution; // Still potentially useful
uniform float u_time;
uniform vec3 u_lightDirection; // Directional light
uniform vec3 u_lightColor;
uniform vec3 u_ambientColor;
uniform vec3 u_viewPosition; // Camera position for specular, etc.

// Texture samplers - will be available when textures are uploaded
// Example: uniform sampler2D u_texture0; // [BaseMap]
// You can add more textures as needed

varying vec3 v_normal;
varying vec3 v_worldPosition;
varying vec2 v_texcoord; // Texture coordinates from vertex shader

void main() {
  vec3 normal = normalize(v_normal);

  // Ambient light
  vec3 ambient = u_ambientColor;

  // Diffuse light
  vec3 lightDir = normalize(u_lightDirection);
  float diff = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = diff * u_lightColor;

  // Placeholder for object's base color - can be replaced by user's shader logic
  vec3 objectBaseColor = vec3(0.5, 0.5, 0.8); 

  // Apply time-based variation to object color (example)
  float r = 0.5 + 0.5 * cos(u_time + v_worldPosition.x * 0.5 + v_worldPosition.z * 0.3);
  float g = 0.5 + 0.5 * sin(u_time * 0.8 + v_worldPosition.y * 0.5);
  float b = 0.5 + 0.5 * cos(u_time * 1.2 + v_worldPosition.z * 0.5 - v_worldPosition.x * 0.2);
  objectBaseColor = mix(objectBaseColor, vec3(r,g,b), 0.7);

  // Example of how to use textures:
  // If you've uploaded a texture with ID "texture0":
  // vec4 texColor = texture2D(u_texture0, v_texcoord);
  // objectBaseColor = mix(objectBaseColor, texColor.rgb, 0.8);

  // If model doesn't have UVs, you can generate them from position:
  // vec4 texColor = texture2D(u_texture0, vec2(v_worldPosition.x, v_worldPosition.z) * 0.5 + 0.5);

  vec3 finalColor = (ambient + diffuse) * objectBaseColor;

  gl_FragColor = vec4(finalColor, 1.0);
}`;

    // State
    let state = {
      renderMode: '3D',
      editorVisible: true,
      controlPanelVisible: true, // Control panel visibility state
      currentFragmentShader: DEFAULT_FRAGMENT_SHADER_3D,
      activeFragmentShader: DEFAULT_FRAGMENT_SHADER_3D,
      lastSuccessfulFragmentShader: DEFAULT_FRAGMENT_SHADER_3D,
      activeVertexShader: DEFAULT_VERTEX_SHADER_3D,
      selectedPrimitive: 'Cube',
      uploadedOBJData: null,
      gl: null,
      program: null,
      lastSuccessfulProgram: null,
      animationFrameId: null,
      autoCompileEnabled: false,
      autoCompileTimerId: null,
      startTime: Date.now(),
      cameraState: {
        angleX: Math.PI / 6,
        angleY: Math.PI / 4,
        distance: 3
      },
      isDragging: false,
      lastMousePosition: null,
      // Texture-specific state
      textures: [],
      showTextureUpload: true, // Show texture panel by default in 3D mode
      // AR-specific state
      xrSession: null,
      xrReferenceSpace: null,
      xrHitTestSource: null,
      xrViewerSpace: null,
      xrSupported: false
    };

    // DOM Elements
    const editorContainer = document.getElementById('editor-container');
    const editorTextarea = document.getElementById('editor-textarea');
    const editorHighlight = document.querySelector('#editor-highlight code');
    const canvas = document.getElementById('shader-canvas');
    const mode2DButton = document.getElementById('mode-2d');
    const mode3DButton = document.getElementById('mode-3d');
    const modeARButton = document.getElementById('mode-ar');
    const primitiveControls = document.getElementById('primitive-controls');
    const primitiveSelect = document.getElementById('primitive-select');
    const uploadObjButton = document.getElementById('upload-obj');
    const objFileInput = document.getElementById('obj-file-input');
    const compileButton = document.getElementById('compile-button');
    // Removed bottom buttons
    // const toggleEditorButton = document.getElementById('toggle-editor');
    const closeEditorButton = document.getElementById('close-editor');
    const errorContainer = document.getElementById('error-container');
    const errorText = document.getElementById('error-text');
    const autoCompileCheckbox = document.getElementById('auto-compile-checkbox');
    // Removed bottom buttons
    // const switchTo2DButton = document.getElementById('switch-to-2d');
    // const switchTo3DButton = document.getElementById('switch-to-3d');
    // const switchToARButton = document.getElementById('switch-to-ar');
    // const floatingUploadObjButton = document.getElementById('floating-upload-obj');
    // Texture-related DOM elements
    const textureControls = document.getElementById('texture-controls');
    const toggleTextureButton = document.getElementById('toggle-texture');
    const textureFileInput = document.getElementById('texture-file-input');
    const texturePanel = document.getElementById('texture-panel');
    const addTextureButton = document.getElementById('add-texture');
    const textureList = document.getElementById('texture-list');
    // Control panel elements
    const toggleControlPanelButton = document.getElementById('toggle-control-panel');
    const controlsBar = document.getElementById('controls-bar');

    // Check for WebXR support
    if ('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        state.xrSupported = supported;
        modeARButton.disabled = !supported;
        switchToARButton.disabled = !supported;

        if (!supported) {
          modeARButton.title = "WebXR AR not supported on this device";
          switchToARButton.title = "WebXR AR not supported on this device";
          modeARButton.classList.add('opacity-50');
          switchToARButton.classList.add('opacity-50');
        }
      });
    } else {
      modeARButton.disabled = true;
      switchToARButton.disabled = true;
      modeARButton.title = "WebXR not supported in this browser";
      switchToARButton.title = "WebXR not supported in this browser";
      modeARButton.classList.add('opacity-50');
      switchToARButton.classList.add('opacity-50');
    }

    // Initialize editor
    editorTextarea.value = state.currentFragmentShader;
    updateHighlight();

    // Initialize auto-compile checkbox
    autoCompileCheckbox.checked = state.autoCompileEnabled;

    // Initialize button visibility based on current render mode
    // Removed bottom buttons
    // switchTo2DButton.style.display = state.renderMode === '3D' || state.renderMode === 'AR' ? 'block' : 'none';
    // switchTo3DButton.style.display = state.renderMode === '2D' || state.renderMode === 'AR' ? 'block' : 'none';
    // switchToARButton.style.display = state.renderMode === '2D' || state.renderMode === '3D' ? 'block' : 'none';
    // floatingUploadObjButton.style.display = state.renderMode === '3D' ? 'block' : 'none';

    // Initialize control panel and texture controls visibility based on state
    controlsBar.style.display = state.controlPanelVisible ? 'flex' : 'none';
    textureControls.style.display = state.renderMode === '3D' && state.controlPanelVisible ? 'flex' : 'none';
    texturePanel.style.display = state.renderMode === '3D' && state.showTextureUpload && state.controlPanelVisible ? 'flex' : 'none';
    toggleTextureButton.textContent = state.showTextureUpload ? 'Hide Textures' : 'Show Textures';
    toggleControlPanelButton.textContent = state.controlPanelVisible ? 'Hide Controls' : 'Show Controls';

    // Initialize WebGL
    initWebGL();

    // Set canvas cursor for 3D mode
    canvas.style.cursor = 'grab';

    // Make editor panel draggable
    makeDraggable(editorContainer);

    // Event Listeners
    editorTextarea.addEventListener('input', function() {
      state.currentFragmentShader = this.value;
      updateHighlight();
    });

    editorTextarea.addEventListener('scroll', function() {
      syncScroll();
    });

    compileButton.addEventListener('click', function() {
      compileShader();
    });

    // Removed bottom buttons
    // toggleEditorButton.addEventListener('click', function() {
    //   toggleEditor();
    // });

    closeEditorButton.addEventListener('click', function() {
      toggleEditor();
    });

    autoCompileCheckbox.addEventListener('change', function() {
      toggleAutoCompile(this.checked);
    });

    mode2DButton.addEventListener('click', function() {
      setRenderMode('2D');
    });

    mode3DButton.addEventListener('click', function() {
      setRenderMode('3D');
    });

    primitiveSelect.addEventListener('change', function() {
      state.selectedPrimitive = this.value;

      // If UploadedOBJ is selected but no OBJ data exists, prompt for upload
      if (this.value === 'UploadedOBJ' && !state.uploadedOBJData) {
        objFileInput.click(); // Open file dialog
        return;
      }

      setupGeometry();
    });

    uploadObjButton.addEventListener('click', function() {
      objFileInput.click();
    });

    objFileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            // Parse the OBJ file
            const objText = e.target.result;
            // We need to import the parseOBJ function from utils/objParser.ts
            // Since we're in a plain HTML file, we'll implement a simplified version
            const objData = parseOBJInline(objText);

            // Store the parsed data
            state.uploadedOBJData = objData;

            // Enable the UploadedOBJ option in the dropdown
            const uploadedObjOption = Array.from(primitiveSelect.options).find(option => option.value === 'UploadedOBJ');
            if (uploadedObjOption) {
              uploadedObjOption.disabled = false;
              primitiveSelect.value = 'UploadedOBJ';
              state.selectedPrimitive = 'UploadedOBJ';
              setupGeometry();
            }

            // Show a success message
            alert('OBJ file loaded successfully!');
          } catch (error) {
            console.error('Error parsing OBJ file:', error);
            alert('Error parsing OBJ file: ' + error.message);
          }
        };
        reader.readAsText(file);
      }
    });

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    canvas.addEventListener('wheel', handleWheel);

    // Event listeners for the new buttons
    // Removed bottom buttons
    // switchTo2DButton.addEventListener('click', function() {
    //   setRenderMode('2D');
    // });

    // switchTo3DButton.addEventListener('click', function() {
    //   setRenderMode('3D');
    // });

    // switchToARButton.addEventListener('click', function() {
    //   if (state.xrSupported) {
    //     setRenderMode('AR');
    //   } else {
    //     alert('WebXR AR is not supported on this device or browser');
    //   }
    // });

    modeARButton.addEventListener('click', function() {
      if (state.xrSupported) {
        setRenderMode('AR');
      } else {
        alert('WebXR AR is not supported on this device or browser');
      }
    });

    // floatingUploadObjButton.addEventListener('click', function() {
    //   objFileInput.click();
    // });

    // Control panel toggle event listener
    toggleControlPanelButton.addEventListener('click', function() {
      toggleControlPanel();
    });

    // Texture-related event listeners
    toggleTextureButton.addEventListener('click', function() {
      state.showTextureUpload = !state.showTextureUpload;
      texturePanel.style.display = state.showTextureUpload && state.controlPanelVisible ? 'flex' : 'none';
      toggleTextureButton.textContent = state.showTextureUpload ? 'Hide Textures' : 'Show Textures';
    });

    addTextureButton.addEventListener('click', function() {
      textureFileInput.click();
    });

    textureFileInput.addEventListener('change', function(event) {
      const file = event.target.files?.[0];
      if (file) {
        // Create a unique ID for the texture
        const id = `texture${state.textures.length}`;
        const name = file.name.split('.')[0] || id;

        // Create a URL for the image
        const url = URL.createObjectURL(file);

        // Add the new texture to the textures array
        const newTexture = { id, name, url };
        state.textures.push(newTexture);

        // Update the texture list UI
        updateTextureList();

        // Reset the input
        textureFileInput.value = '';

        // Recompile the shader to use the new texture
        compileShader();
      }
    });

    window.addEventListener('beforeunload', function() {
      // Stop auto-compile timer
      stopAutoCompileTimer();

      // Cancel animation frame
      if (state.animationFrameId) {
        cancelAnimationFrame(state.animationFrameId);
      }

      // End AR session if active
      if (state.xrSession) {
        state.xrSession.end();
      }
    });

    // OBJ Parser function (simplified version of utils/objParser.ts)
    function parseOBJInline(text) {
      const objPositions = [[0, 0, 0]]; // OBJ indices are 1-based
      const objNormals = [[0, 0, 0]];   // So add a dummy 0 element

      const vertexPositions = [];
      const vertexNormals = [];

      function addVertex(partsStr) {
        const parts = partsStr.split('/');
        const vIdx = parseInt(parts[0], 10);
        const vnIdx = parts.length > 2 && parts[2] ? parseInt(parts[2], 10) : 0;

        const pos = objPositions[vIdx];
        vertexPositions.push(...pos);

        if (vnIdx > 0) {
          const norm = objNormals[vnIdx];
          vertexNormals.push(...norm);
        } else {
          // If no normal, use a placeholder
          vertexNormals.push(0, 0, 0);
        }
      }

      const lines = text.split('\n');
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine.length === 0 || trimmedLine.startsWith('#')) {
          continue;
        }
        const [keyword, ...values] = trimmedLine.split(/\s+/);

        switch (keyword) {
          case 'v':
            objPositions.push(values.map(parseFloat));
            break;
          case 'vn':
            objNormals.push(values.map(parseFloat));
            break;
          case 'f': {
            // Simple triangulation for quads (assuming convex)
            const numVerticesInFace = values.length;
            if (numVerticesInFace >= 3) {
              addVertex(values[0]);
              addVertex(values[1]);
              addVertex(values[2]);
              if (numVerticesInFace === 4) { // Quad, triangulate
                addVertex(values[0]);
                addVertex(values[2]);
                addVertex(values[3]);
              }
            }
            break;
          }
        }
      }

      // If normals were not present in OBJ or consistently, they need to be computed.
      if (vertexNormals.length !== vertexPositions.length) {
        console.warn("OBJ Parser: Mismatch between vertex and normal counts. Normals might be incorrect or missing.");
        // Fill missing normals with placeholders if necessary
        const expectedNormalCount = vertexPositions.length;
        while(vertexNormals.length < expectedNormalCount) {
          vertexNormals.push(0, 1, 0); // Default up normal
        }
      }

      return { vertices: vertexPositions, normals: vertexNormals };
    }

    // Functions
    function updateHighlight() {
      editorHighlight.textContent = editorTextarea.value;
      Prism.highlightElement(editorHighlight);
      // Synchronize scroll position
      syncScroll();
    }

    // Function to update the texture list UI
    function updateTextureList() {
      // Clear the texture list
      textureList.innerHTML = '';

      // If no textures, show the default message
      if (state.textures.length === 0) {
        const noTexturesMsg = document.createElement('span');
        noTexturesMsg.className = 'text-gray-400 text-sm';
        noTexturesMsg.textContent = 'No textures added yet. Click "Add Texture" to upload.';
        textureList.appendChild(noTexturesMsg);
        return;
      }

      // Add each texture to the list
      state.textures.forEach((texture) => {
        const textureItem = document.createElement('div');
        textureItem.className = 'flex flex-col items-center bg-gray-700 p-2 rounded';

        const textureImg = document.createElement('img');
        textureImg.src = texture.url;
        textureImg.alt = texture.name;
        textureImg.className = 'w-12 h-12 object-cover rounded mb-1';

        const textureName = document.createElement('span');
        textureName.className = 'text-xs text-white';
        textureName.textContent = texture.name;

        const textureUniform = document.createElement('span');
        textureUniform.className = 'text-xs text-gray-400';
        textureUniform.textContent = `u_${texture.id}`;

        textureItem.appendChild(textureImg);
        textureItem.appendChild(textureName);
        textureItem.appendChild(textureUniform);

        textureList.appendChild(textureItem);
      });
    }

    function syncScroll() {
      // Sync the scroll position of the highlighting element with the textarea
      const highlightElement = document.querySelector('#editor-highlight');
      highlightElement.scrollTop = editorTextarea.scrollTop;
      highlightElement.scrollLeft = editorTextarea.scrollLeft;
    }

    function toggleControlPanel() {
      state.controlPanelVisible = !state.controlPanelVisible;

      // Update control panel elements visibility
      controlsBar.style.display = state.controlPanelVisible ? 'flex' : 'none';
      if (state.renderMode === '3D' && state.showTextureUpload) {
        texturePanel.style.display = state.controlPanelVisible ? 'flex' : 'none';
      }

      // Update button text
      toggleControlPanelButton.textContent = state.controlPanelVisible ? 'Hide Controls' : 'Show Controls';

      // Adjust editor position based on control panel visibility
      if (state.controlPanelVisible) {
        editorContainer.style.top = '24px'; // Position below control panel
      } else {
        editorContainer.style.top = '4px';  // Position at top when control panel is hidden
      }
    }

    function toggleEditor() {
      state.editorVisible = !state.editorVisible;
      editorContainer.style.display = state.editorVisible ? 'flex' : 'none';
      // Removed bottom buttons
      // toggleEditorButton.textContent = state.editorVisible ? 'Hide Editor' : 'Show Editor';

      // If editor is hidden, stop auto-compile
      if (!state.editorVisible && state.autoCompileEnabled) {
        toggleAutoCompile(false);
        autoCompileCheckbox.checked = false;
      }
    }

    function toggleAutoCompile(enable) {
      if (enable === state.autoCompileEnabled) return; // No change

      state.autoCompileEnabled = enable;

      if (enable) {
        startAutoCompileTimer();
      } else {
        stopAutoCompileTimer();
      }
    }

    function startAutoCompileTimer() {
      // Clear any existing timer first
      stopAutoCompileTimer();

      // Start a new timer that compiles every second
      state.autoCompileTimerId = setInterval(function() {
        compileShader();
      }, 1000);
    }

    function stopAutoCompileTimer() {
      if (state.autoCompileTimerId !== null) {
        clearInterval(state.autoCompileTimerId);
        state.autoCompileTimerId = null;
      }
    }

    function setRenderMode(mode) {
      // If we're already in AR mode and trying to switch to another mode, end the AR session first
      if (state.renderMode === 'AR' && mode !== 'AR') {
        endARSession();
      }

      // If we're switching to AR mode, start the AR session
      if (mode === 'AR') {
        if (state.xrSupported) {
          startARSession();
          return; // The rest of the mode switching will happen after the AR session starts
        } else {
          alert('WebXR AR is not supported on this device or browser');
          return; // Don't proceed with mode change if AR is not supported
        }
      }

      // Store auto-compile state before changing mode
      const wasAutoCompileEnabled = state.autoCompileEnabled;

      // Temporarily disable auto-compile during mode change
      if (wasAutoCompileEnabled) {
        toggleAutoCompile(false);
      }

      state.renderMode = mode;

      // Update UI
      mode2DButton.className = mode === '2D' 
        ? 'px-3 py-1 rounded text-sm bg-indigo-500 text-white'
        : 'px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500';

      mode3DButton.className = mode === '3D'
        ? 'px-3 py-1 rounded text-sm bg-indigo-500 text-white'
        : 'px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500';

      modeARButton.className = mode === 'AR'
        ? 'px-3 py-1 rounded text-sm bg-indigo-500 text-white'
        : 'px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500';

      primitiveControls.style.display = mode === '3D' && state.controlPanelVisible ? 'flex' : 'none';

      // Show/hide the texture controls and panel
      textureControls.style.display = mode === '3D' && state.controlPanelVisible ? 'flex' : 'none';
      texturePanel.style.display = mode === '3D' && state.showTextureUpload && state.controlPanelVisible ? 'flex' : 'none';
      toggleTextureButton.textContent = state.showTextureUpload ? 'Hide Textures' : 'Show Textures';

      // Show/hide the new buttons based on the current render mode
      // Removed bottom buttons
      // switchTo2DButton.style.display = (mode === '3D' || mode === 'AR') ? 'block' : 'none';
      // switchTo3DButton.style.display = (mode === '2D' || mode === 'AR') ? 'block' : 'none';
      // switchToARButton.style.display = (mode === '2D' || mode === '3D') ? 'block' : 'none';
      // floatingUploadObjButton.style.display = mode === '3D' ? 'block' : 'none';

      // Update shaders
      if (mode === '2D') {
        state.activeVertexShader = DEFAULT_VERTEX_SHADER_2D;
        state.currentFragmentShader = DEFAULT_FRAGMENT_SHADER_2D;
        state.activeFragmentShader = DEFAULT_FRAGMENT_SHADER_2D;
        state.lastSuccessfulFragmentShader = DEFAULT_FRAGMENT_SHADER_2D;
        state.lastSuccessfulProgram = null; // Reset last successful program when changing modes
      } else {
        state.activeVertexShader = DEFAULT_VERTEX_SHADER_3D;
        state.currentFragmentShader = DEFAULT_FRAGMENT_SHADER_3D;
        state.activeFragmentShader = DEFAULT_FRAGMENT_SHADER_3D;
        state.lastSuccessfulFragmentShader = DEFAULT_FRAGMENT_SHADER_3D;
        state.lastSuccessfulProgram = null; // Reset last successful program when changing modes
      }

      // Update editor
      editorTextarea.value = state.currentFragmentShader;
      updateHighlight();

      // Reinitialize WebGL
      initWebGL();

      // Restore auto-compile state if it was enabled
      if (wasAutoCompileEnabled) {
        toggleAutoCompile(true);
        autoCompileCheckbox.checked = true;
      }
    }

    // WebXR AR functions
    async function startARSession() {
      if (!state.xrSupported || !navigator.xr) {
        alert('WebXR AR is not supported on this device or browser');
        return;
      }

      try {
        // Request an immersive-ar session
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'local'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });

        state.xrSession = session;

        // Set up the WebGL context for XR
        const gl = canvas.getContext('webgl', { xrCompatible: true });
        state.gl = gl;

        // Set up the XR WebGL layer
        const xrGlLayer = new XRWebGLLayer(session, gl);
        session.updateRenderState({ baseLayer: xrGlLayer });

        // Get the reference space
        state.xrReferenceSpace = await session.requestReferenceSpace('local');
        state.xrViewerSpace = await session.requestReferenceSpace('viewer');

        // Set up hit testing
        const hitTestSource = await session.requestHitTestSource({
          space: state.xrViewerSpace
        });
        state.xrHitTestSource = hitTestSource;

        // Set up session end event handler
        session.addEventListener('end', () => {
          state.xrSession = null;
          state.xrReferenceSpace = null;
          state.xrHitTestSource = null;
          state.xrViewerSpace = null;

          // Switch back to 3D mode when AR session ends
          setRenderMode('3D');
        });

        // Update state and UI
        state.renderMode = 'AR';

        // Update UI
        mode2DButton.className = 'px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500';
        mode3DButton.className = 'px-3 py-1 rounded text-sm bg-gray-600 hover:bg-gray-500';
        modeARButton.className = 'px-3 py-1 rounded text-sm bg-indigo-500 text-white';

        primitiveControls.style.display = 'none';

        // Hide texture controls and panel in AR mode
        textureControls.style.display = 'none';
        texturePanel.style.display = 'none';

        // Keep control panel toggle button visible in AR mode
        toggleControlPanelButton.style.display = 'block';

        // Show/hide the new buttons
        // Removed bottom buttons
        // switchTo2DButton.style.display = 'block';
        // switchTo3DButton.style.display = 'block';
        // switchToARButton.style.display = 'none';
        // floatingUploadObjButton.style.display = 'none';

        // Set up the WebGL program for AR
        setupARRendering(session);

      } catch (error) {
        console.error('Error starting AR session:', error);
        alert('Error starting AR session: ' + error.message);
      }
    }

    function endARSession() {
      if (state.xrSession) {
        state.xrSession.end();
        // The session's 'end' event handler will clean up the state
      }
    }

    function setupARRendering(session) {
      // Create shader program for AR
      try {
        const vertexShader = createShader(state.gl, state.gl.VERTEX_SHADER, state.activeVertexShader);
        const fragmentShader = createShader(state.gl, state.gl.FRAGMENT_SHADER, state.activeFragmentShader);
        const program = createProgram(state.gl, vertexShader, fragmentShader);

        state.program = program;
        state.lastSuccessfulProgram = program;

        // Set up geometry for AR (use the same as 3D mode)
        setupGeometry();

        // Set up XR frame loop
        session.requestAnimationFrame(renderARFrame);
      } catch (error) {
        console.error('Error setting up AR rendering:', error);
        showError('Error setting up AR rendering: ' + error.message);
        endARSession();
      }
    }

    function renderARFrame(time, frame) {
      const session = state.xrSession;

      if (!session) return;

      // Request the next frame
      session.requestAnimationFrame(renderARFrame);

      const gl = state.gl;
      const program = state.program;

      if (!gl || !program) return;

      // Get the XR pose
      const referenceSpace = state.xrReferenceSpace;
      const pose = frame.getViewerPose(referenceSpace);

      if (!pose) return;

      // Get the WebGL layer
      const glLayer = session.renderState.baseLayer;

      // Bind the WebGL layer's framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

      // Clear the framebuffer
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Enable depth testing
      gl.enable(gl.DEPTH_TEST);

      // Use the program
      gl.useProgram(program);

      // Set time uniform
      const timeLocation = gl.getUniformLocation(program, 'u_time');
      const currentTime = (Date.now() - state.startTime) / 1000;
      gl.uniform1f(timeLocation, currentTime);

      // Process hit test results
      const hitTestResults = frame.getHitTestResults(state.xrHitTestSource);

      if (hitTestResults.length > 0) {
        // Get the hit test pose
        const hitPose = hitTestResults[0].getPose(referenceSpace);

        if (hitPose) {
          // Render the 3D object at the hit test position
          for (const view of pose.views) {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            // Set projection and view matrices from the XR view
            const projectionMatrix = view.projectionMatrix;
            const viewMatrix = view.transform.inverse.matrix;

            // Set uniforms
            const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

            const viewMatrixLocation = gl.getUniformLocation(program, 'u_viewMatrix');
            gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);

            // Create model matrix from hit test pose
            const modelMatrix = new Float32Array([
              hitPose.transform.orientation.x, hitPose.transform.orientation.y, hitPose.transform.orientation.z, 0,
              hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z, 0,
              0, 0, 0, 0,
              0, 0, 0, 1
            ]);

            const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
            gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);

            // Set normal matrix (simplified for this example)
            const normalMatrix = createIdentityMatrix();
            const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
            gl.uniformMatrix4fv(normalMatrixLocation, false, normalMatrix);

            // Set light direction
            const lightDirectionLocation = gl.getUniformLocation(program, 'u_lightDirection');
            gl.uniform3f(lightDirectionLocation, 0.5, 0.75, 1.0);

            // Set light color
            const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor');
            gl.uniform3f(lightColorLocation, 1.0, 1.0, 1.0);

            // Set ambient color
            const ambientColorLocation = gl.getUniformLocation(program, 'u_ambientColor');
            gl.uniform3f(ambientColorLocation, 0.2, 0.2, 0.3);

            // Set view position
            const viewPos = [view.transform.position.x, view.transform.position.y, view.transform.position.z];
            const viewPositionLocation = gl.getUniformLocation(program, 'u_viewPosition');
            gl.uniform3f(viewPositionLocation, viewPos[0], viewPos[1], viewPos[2]);

            // Draw the 3D geometry
            if (state.selectedPrimitive === 'UploadedOBJ' && state.uploadedOBJData) {
              gl.drawArrays(gl.TRIANGLES, 0, state.numIndices);
            } else {
              gl.drawElements(gl.TRIANGLES, state.numIndices, gl.UNSIGNED_SHORT, 0);
            }
          }
        }
      }
    }

    function compileShader() {
      state.activeFragmentShader = state.currentFragmentShader;
      initWebGL();
    }

    function initWebGL() {
      // If we're in AR mode, don't reinitialize WebGL as it's handled by the AR session
      if (state.renderMode === 'AR' && state.xrSession) {
        return;
      }

      // Store auto-compile state before reinitializing
      const wasAutoCompileEnabled = state.autoCompileEnabled;

      // Temporarily disable auto-compile during reinitialization
      if (wasAutoCompileEnabled) {
        toggleAutoCompile(false);
      }

      // Cancel any existing animation frame
      if (state.animationFrameId) {
        cancelAnimationFrame(state.animationFrameId);
      }

      try {
        // Get WebGL context
        const gl = canvas.getContext('webgl', { xrCompatible: true }) || canvas.getContext('experimental-webgl', { xrCompatible: true });
        if (!gl) {
          showError('WebGL is not supported in your browser');
          // Don't return here, let the finally block handle restoring auto-compile
        } else {
          state.gl = gl;

          // Resize canvas
          resizeCanvas();

          // Create shader program
          try {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, state.activeVertexShader);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, state.activeFragmentShader);
            const newProgram = createProgram(gl, vertexShader, fragmentShader);

            // Compilation successful, update the program and store as last successful
            state.program = newProgram;
            state.lastSuccessfulProgram = newProgram;
            state.lastSuccessfulFragmentShader = state.activeFragmentShader;

            hideError();

            // Setup geometry based on render mode
            setupGeometry();

            // Start rendering
            render();
          } catch (error) {
            // Compilation failed, show error
            showError(error.message);

            // If we have a previous successful program, use it
            if (state.lastSuccessfulProgram && state.gl) {
              // Revert to the last successful fragment shader
              state.activeFragmentShader = state.lastSuccessfulFragmentShader;

              // Use the last successful program
              state.program = state.lastSuccessfulProgram;

              // Setup geometry and continue rendering with the last successful program
              setupGeometry();
              render();
            }
            // Don't return here, let the finally block handle restoring auto-compile
          }
        }
      } finally {
        // Restore auto-compile state if it was enabled, regardless of whether there was an error
        if (wasAutoCompileEnabled) {
          toggleAutoCompile(true);
        }
      }
    }

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error('Could not compile shader:\n' + info);
      }

      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error('Could not link program:\n' + info);
      }

      return program;
    }

    function setupGeometry() {
      const gl = state.gl;
      const program = state.program;

      if (!gl || !program) return;

      gl.useProgram(program);

      if (state.renderMode === '2D') {
        // Create a 2D quad that covers the entire canvas
        const positions = [
          -1, -1,
          1, -1,
          -1, 1,
          1, 1
        ];

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      } else {
        // 3D geometry setup
        let positions, normals, indices, texcoords;

        if (state.selectedPrimitive === 'Cube') {
          // Create cube geometry
          positions = [
            // Front face
            -0.5, -0.5, 0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, 0.5,
            -0.5, 0.5, 0.5,

            // Back face
            -0.5, -0.5, -0.5,
            -0.5, 0.5, -0.5,
            0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,

            // Top face
            -0.5, 0.5, -0.5,
            -0.5, 0.5, 0.5,
            0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,

            // Bottom face
            -0.5, -0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            -0.5, -0.5, 0.5,

            // Right face
            0.5, -0.5, -0.5,
            0.5, 0.5, -0.5,
            0.5, 0.5, 0.5,
            0.5, -0.5, 0.5,

            // Left face
            -0.5, -0.5, -0.5,
            -0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5
          ];

          normals = [
            // Front face
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,

            // Back face
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,

            // Top face
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,

            // Bottom face
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,

            // Right face
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,

            // Left face
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0
          ];

          // Texture coordinates for cube
          texcoords = [
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,

            // Back face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Top face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,

            // Bottom face
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,

            // Right face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,

            // Left face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
          ];

          indices = [
            0, 1, 2, 0, 2, 3,       // Front face
            4, 5, 6, 4, 6, 7,       // Back face
            8, 9, 10, 8, 10, 11,    // Top face
            12, 13, 14, 12, 14, 15, // Bottom face
            16, 17, 18, 16, 18, 19, // Right face
            20, 21, 22, 20, 22, 23  // Left face
          ];
        } else if (state.selectedPrimitive === 'Sphere') {
          // Create sphere geometry
          const radius = 0.5;
          const latitudeBands = 30;
          const longitudeBands = 30;

          positions = [];
          normals = [];
          indices = [];
          texcoords = [];

          // Generate vertices
          for (let lat = 0; lat <= latitudeBands; lat++) {
            const theta = lat * Math.PI / latitudeBands;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);

            for (let lon = 0; lon <= longitudeBands; lon++) {
              const phi = lon * 2 * Math.PI / longitudeBands;
              const sinPhi = Math.sin(phi);
              const cosPhi = Math.cos(phi);

              const x = cosPhi * sinTheta;
              const y = cosTheta;
              const z = sinPhi * sinTheta;

              // Texture coordinates: u is longitude, v is latitude
              const u = 1 - (lon / longitudeBands);
              const v = 1 - (lat / latitudeBands);
              texcoords.push(u, v);

              positions.push(radius * x, radius * y, radius * z);
              normals.push(x, y, z);
            }
          }

          // Generate indices
          for (let lat = 0; lat < latitudeBands; lat++) {
            for (let lon = 0; lon < longitudeBands; lon++) {
              const first = (lat * (longitudeBands + 1)) + lon;
              const second = first + longitudeBands + 1;

              indices.push(first, second, first + 1);
              indices.push(second, second + 1, first + 1);
            }
          }
        } else if (state.selectedPrimitive === 'UploadedOBJ' && state.uploadedOBJData) {
          // Use the uploaded OBJ data
          positions = state.uploadedOBJData.vertices;
          normals = state.uploadedOBJData.normals;
          texcoords = state.uploadedOBJData.texcoords || [];

          // For uploaded OBJ, we'll use non-indexed drawing
          // Create position buffer
          const positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

          const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
          gl.enableVertexAttribArray(positionAttributeLocation);
          gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

          // Create normal buffer
          const normalBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

          const normalAttributeLocation = gl.getAttribLocation(program, 'a_normal');
          gl.enableVertexAttribArray(normalAttributeLocation);
          gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

          // Create texture coordinate buffer if available
          const texcoordAttributeLocation = gl.getAttribLocation(program, 'a_texcoord');
          if (texcoords.length > 0 && texcoordAttributeLocation !== -1) {
            const texcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(texcoordAttributeLocation);
            gl.vertexAttribPointer(texcoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);
          } else if (texcoordAttributeLocation !== -1) {
            // If no texture coordinates are available, disable the attribute
            gl.disableVertexAttribArray(texcoordAttributeLocation);
          }

          // Store the number of vertices for drawing
          state.numIndices = positions.length / 3;

          // Use TRIANGLES instead of ELEMENT_ARRAY_BUFFER for non-indexed drawing
          state.drawMode = gl.TRIANGLES;

          // Return early since we've already set up the buffers
          return;
        }

        // Create position buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        // Create normal buffer
        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        const normalAttributeLocation = gl.getAttribLocation(program, 'a_normal');
        gl.enableVertexAttribArray(normalAttributeLocation);
        gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        // Create texture coordinate buffer
        const texcoordAttributeLocation = gl.getAttribLocation(program, 'a_texcoord');
        if (texcoordAttributeLocation !== -1) {
          const texcoordBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(texcoordAttributeLocation);
          gl.vertexAttribPointer(texcoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        }

        // Create index buffer
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Store the number of indices for drawing
        state.numIndices = indices.length;

        // Use ELEMENT_ARRAY_BUFFER for indexed drawing
        state.drawMode = gl.TRIANGLES;
      }
    }

    function render() {
      const gl = state.gl;
      const program = state.program;

      if (!gl || !program) return;

      // Resize canvas if needed
      resizeCanvas();

      // Clear the canvas
      gl.clearColor(0.1, 0.1, 0.1, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Enable depth testing for 3D
      if (state.renderMode === '3D') {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }

      // Use the program
      gl.useProgram(program);

      // Set uniforms
      const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

      const timeLocation = gl.getUniformLocation(program, 'u_time');
      const currentTime = (Date.now() - state.startTime) / 1000;
      gl.uniform1f(timeLocation, currentTime);

      if (state.renderMode === '3D') {
        // Set up matrices for 3D rendering
        const { angleX, angleY, distance } = state.cameraState;

        // Model matrix (identity for now)
        const modelMatrix = createIdentityMatrix();
        const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
        gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);

        // View matrix (camera)
        const viewMatrix = createViewMatrix(angleX, angleY, distance);
        const viewMatrixLocation = gl.getUniformLocation(program, 'u_viewMatrix');
        gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);

        // Projection matrix
        const aspect = canvas.width / canvas.height;
        const projectionMatrix = createPerspectiveMatrix(45 * Math.PI / 180, aspect, 0.1, 100.0);
        const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
        gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

        // Normal matrix
        const normalMatrix = createIdentityMatrix(); // Simplified for this example
        const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
        gl.uniformMatrix4fv(normalMatrixLocation, false, normalMatrix);

        // Light direction
        const lightDirectionLocation = gl.getUniformLocation(program, 'u_lightDirection');
        gl.uniform3f(lightDirectionLocation, 0.5, 0.75, 1.0);

        // Light color
        const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor');
        gl.uniform3f(lightColorLocation, 1.0, 1.0, 1.0);

        // Ambient color
        const ambientColorLocation = gl.getUniformLocation(program, 'u_ambientColor');
        gl.uniform3f(ambientColorLocation, 0.2, 0.2, 0.3);

        // View position (camera position)
        const viewPos = getCameraPosition(angleX, angleY, distance);
        const viewPositionLocation = gl.getUniformLocation(program, 'u_viewPosition');
        gl.uniform3f(viewPositionLocation, viewPos[0], viewPos[1], viewPos[2]);

        // Bind textures if available
        if (state.textures && state.textures.length > 0) {
          state.textures.forEach((texture, index) => {
            // Create texture if it doesn't exist
            if (!texture.glTexture) {
              const glTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, glTexture);

              // Use a temporary 1x1 pixel until the image loads
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
                           new Uint8Array([0, 0, 0, 255])); // Black pixel

              // Load the image
              const image = new Image();
              image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                // Check if the image dimensions are powers of 2
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                  gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                  // Not a power of 2, disable mipmap and set wrapping to clamp to edge
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
              };
              image.src = texture.url;

              // Store the texture in the texture object
              texture.glTexture = glTexture;
            }

            // Get the uniform location for this texture
            const samplerName = `u_${texture.id}`;
            const samplerLocation = gl.getUniformLocation(program, samplerName);

            if (samplerLocation) {
              // Activate texture unit
              gl.activeTexture(gl.TEXTURE0 + index);
              gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);
              gl.uniform1i(samplerLocation, index);
            }
          });
        }

        // Draw the 3D geometry
        if (state.selectedPrimitive === 'UploadedOBJ' && state.uploadedOBJData) {
          // Use non-indexed drawing for uploaded OBJ
          gl.drawArrays(gl.TRIANGLES, 0, state.numIndices);
        } else {
          // Use indexed drawing for built-in primitives
          gl.drawElements(gl.TRIANGLES, state.numIndices, gl.UNSIGNED_SHORT, 0);
        }
      } else {
        // Draw the 2D quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      // Request the next frame
      state.animationFrameId = requestAnimationFrame(render);
    }

    function resizeCanvas() {
      const displayWidth = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;

      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        state.gl.viewport(0, 0, canvas.width, canvas.height);
      }
    }

    // Helper function to check if a number is a power of 2
    function isPowerOf2(value) {
      return (value & (value - 1)) === 0;
    }

    function showError(message) {
      errorContainer.classList.remove('hidden');
      errorText.textContent = message;
    }

    function hideError() {
      errorContainer.classList.add('hidden');
      errorText.textContent = '';
    }

    function makeDraggable(element) {
      const dragHandle = element.querySelector('.drag-handle');
      let isDragging = false;
      let offsetX, offsetY;

      dragHandle.addEventListener('mousedown', function(e) {
        isDragging = true;
        offsetX = e.clientX - element.getBoundingClientRect().left;
        offsetY = e.clientY - element.getBoundingClientRect().top;
        dragHandle.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;

        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;

        // Keep the element within the viewport
        const maxX = window.innerWidth - element.offsetWidth;
        const maxY = window.innerHeight - element.offsetHeight;

        element.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
        element.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
      });

      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          dragHandle.style.cursor = 'move';
        }
      });
    }

    function handleMouseDown(event) {
      if (state.renderMode !== '3D') return;

      state.isDragging = true;
      state.lastMousePosition = { x: event.clientX, y: event.clientY };
      canvas.style.cursor = 'grabbing';
    }

    function handleMouseMove(event) {
      if (state.renderMode !== '3D' || !state.isDragging || !state.lastMousePosition) return;

      const dx = event.clientX - state.lastMousePosition.x;
      const dy = event.clientY - state.lastMousePosition.y;

      state.cameraState.angleY += dx * 0.005;
      state.cameraState.angleX -= dy * 0.005;

      // Clamp angleX to avoid flipping
      state.cameraState.angleX = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, state.cameraState.angleX));

      state.lastMousePosition = { x: event.clientX, y: event.clientY };
    }

    function handleMouseUp() {
      if (state.renderMode !== '3D') return;

      state.isDragging = false;
      canvas.style.cursor = 'grab';
    }

    function handleWheel(event) {
      if (state.renderMode !== '3D') return;

      event.preventDefault();
      const zoomSensitivity = 0.001;
      state.cameraState.distance = Math.max(0.5, Math.min(20, state.cameraState.distance + event.deltaY * zoomSensitivity * state.cameraState.distance));
    }

    // Matrix utility functions
    function createIdentityMatrix() {
      return new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ]);
    }

    function createViewMatrix(angleX, angleY, distance) {
      const cameraPosition = getCameraPosition(angleX, angleY, distance);
      const target = [0, 0, 0];
      const up = [0, 1, 0];

      // Simplified look-at matrix calculation
      const z = normalize(subtractVectors(cameraPosition, target));
      const x = normalize(crossProduct(up, z));
      const y = crossProduct(z, x);

      return new Float32Array([
        x[0], y[0], z[0], 0,
        x[1], y[1], z[1], 0,
        x[2], y[2], z[2], 0,
        -dotProduct(x, cameraPosition), -dotProduct(y, cameraPosition), -dotProduct(z, cameraPosition), 1
      ]);
    }

    function getCameraPosition(angleX, angleY, distance) {
      return [
        distance * Math.cos(angleX) * Math.sin(angleY),
        distance * Math.sin(angleX),
        distance * Math.cos(angleX) * Math.cos(angleY)
      ];
    }

    function createPerspectiveMatrix(fovY, aspect, near, far) {
      const f = 1.0 / Math.tan(fovY / 2);
      const nf = 1 / (near - far);

      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, 2 * far * near * nf, 0
      ]);
    }

    function subtractVectors(a, b) {
      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    function normalize(v) {
      const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      if (length > 0.00001) {
        return [v[0] / length, v[1] / length, v[2] / length];
      }
      return [0, 0, 0];
    }

    function crossProduct(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    }

    function dotProduct(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
  </script>
</body>
</html>
